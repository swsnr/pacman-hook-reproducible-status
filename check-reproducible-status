#!/usr/bin/python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

import sys
import json
from urllib.request import urlopen
from ctypes import CDLL, Structure, c_char_p, c_uint, c_int, byref, POINTER
from contextlib import contextmanager
from urllib.parse import urlparse


libalpm = CDLL('libalpm.so')

class alpm_handle_t(Structure):
    pass
alpm_handle_t_ptr = POINTER(alpm_handle_t)
class alpm_db_t(Structure):
    pass
alpm_db_t_ptr = POINTER(alpm_db_t)
class alpm_pkg_t(Structure):
    pass
alpm_pkg_t_ptr = POINTER(alpm_pkg_t)

libalpm.alpm_initialize.argtypes = [c_char_p, c_char_p, POINTER(c_uint)]
libalpm.alpm_initialize.restype = alpm_handle_t_ptr
libalpm.alpm_release.argtypes = [alpm_handle_t_ptr]
libalpm.alpm_release.restype = c_int
libalpm.alpm_get_localdb.argtypes = [alpm_handle_t_ptr]
libalpm.alpm_get_localdb.restype = alpm_db_t_ptr
libalpm.alpm_db_get_pkg.argtypes = [alpm_db_t_ptr, c_char_p]
libalpm.alpm_db_get_pkg.restype = alpm_pkg_t_ptr
libalpm.alpm_pkg_get_version.argtypes = [alpm_pkg_t_ptr]
libalpm.alpm_pkg_get_version.restype = c_char_p
libalpm.alpm_pkg_vercmp.argtypes = [c_char_p, c_char_p]
libalpm.alpm_pkg_vercmp.restype = c_int


REBUILDERS = [
'https://reproducible.archlinux.org',
'https://r-b.engineering.nyu.edu'
]


@contextmanager
def alpm_handle():
    errno = c_uint()
    handle = libalpm.alpm_initialize('/'.encode('utf-8'),
        '/var/lib/pacman'.encode('utf-8'), byref(errno))
    if handle is None:
        raise ValueError(f'alpm_initialize failed with error {errno}')
    yield handle
    libalpm.alpm_release(handle)


def main():
    rebuilder_packages = {}
    for rebuilder in REBUILDERS:
        url = f'{rebuilder}/api/v0/pkgs/list'
        basename = urlparse(url).netloc
        try:
            with urlopen(url) as source:
                 rebuilder_packages[basename] = {
                    p['name']: p for p in json.load(source)}
        except Exception as error:
            print(f'Rebuilder {rebuilder} failed: {error}', file=sys.stderr)
            rebuilder_packages[basename] = {}

    with alpm_handle() as handle:
        localdb = libalpm.alpm_get_localdb(handle)
        for line in sys.stdin:
            pkgname = line.strip()
            pkg = libalpm.alpm_db_get_pkg(localdb, pkgname.encode('utf-8'))
            if not pkg:
                print(f'WARN: {pkgname} not found in local database!')
                continue
            pkgver = libalpm.alpm_pkg_get_version(pkg).decode('utf-8')
            state_by_rebuilder = {}
            for rebuilder, packages in rebuilder_packages.items():
                pkginfo = packages.get(pkgname)
                if not pkginfo:
                    state_by_rebuilder[rebuilder] = ('missing', 'n/a')
                    continue
                status = pkginfo['status']
                repro_pkgver = pkginfo['version']
                if libalpm.alpm_pkg_vercmp(pkgver.encode('utf-8'),
                                           repro_pkgver.encode('utf-8')) != 0:
                    # If the version doesn't match the rebuilder doesn't have
                    # the current version
                    state_by_rebuilder[rebuilder] = ('version mismatch', repro_pkgver)
                else:
                    state_by_rebuilder[rebuilder] = (status, repro_pkgver)
            if all(v[0] == 'GOOD' for v in state_by_rebuilder.values()):
                # All rebuilders successfully reproduced the package
                continue
            elif any(v[0] == 'GOOD' for v in state_by_rebuilder.values()):
                print(f'Package {pkgname} {pkgver} partially reproduced')
                for rebuilder, (status, version) in state_by_rebuilder.items():
                    if status != 'GOOD':
                        print(f'   {rebuilder}: {version} {status}')
            else:
                # No rebuilder successfully reproduced the package
                print(f'Package {pkgname} {pkgver} not reproduced by any rebuilder')
                for rebuilder, (status, version) in state_by_rebuilder.items():
                    print(f'   {rebuilder}: {version} {status}')


if __name__ == '__main__':
    main()
